This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
🤖 AI/
  ADR-AI-001-three-layer-cache.md
  ADR-AI-002-gtd-kanban-integration.md
  ADR-AI-003-extensible-graph-edges.md
ADR-001-cli-rag.toml.md
ADR-002-Visual-Mode-planning.md
ADR-003a-CLI-refactor-planning.md
ADR-003b-v1-CLI-commands.md
ADR-003c-v1.1-CLI-commands (needs edit).md
ADR-004-toml-config-versioning.md
ADR-005-MCP-server-wrapper.md
ADR-006-config-loader-error-codes.md
ADR-007-general-error-codes-ideation.md
ADR-008-ai-rag.toml.md
ADR-009-GTD-ideation.md
ADR-010-the-LUA-escape-hatch.md
ADR-011-text-parsing-stack.md
ADR-012-create-man-pages.md
ADR-013-notebook-documentation.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="🤖 AI/ADR-AI-001-three-layer-cache.md">
---
id: ADR-AI-001
tags:
  - cache
  - performance
  - index
  - multi-process
  - state-management
status: accepted
depends_on: 
  - ADR-001
  - ADR-003c
created_date: 2025-08-30
last_modified: 2025-08-30
related_files: [src/index.rs, src/cache.rs, src/watch.rs]
---

# ADR-AI-001-three-layer-cache

## Objective
<!-- A concise statement explaining the goal of this decision. -->
Implement a three-layer cache architecture to enable fast access patterns, computed metadata, and session-based tracking without excessive disk writes or repository churn.

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->
The cli-rag system needs to track various types of metadata with different persistence requirements:

1. **Volatile session data** (access patterns, current TODO states) that shouldn't persist between sessions
2. **Computed metadata** (token counts, section ranges, graph traversals) that's expensive to calculate but can be rebuilt
3. **Source of truth** (note frontmatter) that must be preserved and portable

Current challenges:
- Tracking access frequency would cause excessive git churn if written to notes
- Token counting and summarization are expensive operations we don't want to repeat
- Multi-process access (CLI + Neovim + watch) creates potential for race conditions
- Graph traversals and semantic clustering are expensive to recalculate on every query

The PageIndex analysis revealed the value of treating the index as a cache of expensive computations rather than primary storage. This aligns with our principle that "what can be calculated from the graph should be."

## Decision
<!-- What is the change that we're proposing and/or doing? -->
Adopt a three-layer cache architecture with file-based locking for multi-process coordination:

**Layer 1 - Memory Cache (session-only)**
- Access patterns, active TODOs, current graph traversals
- Lost on process exit, never causes disk writes

**Layer 2 - Disk Cache (persistent but rebuildable)**  
- Token counts, section ranges, semantic clusters, computed graph metadata
- Written with debouncing (5 second intervals)
- Can be fully rebuilt from source via `validate --rebuild-cache`

**Layer 3 - Note Files (source of truth)**
- Only user-initiated changes (frontmatter, content)
- Portable, git-trackable, Obsidian-compatible

**Multi-process coordination via file locking:**
```rust
// Simple advisory locking
let lock_file = ".cli-rag/index.lock";
acquire_lock_with_timeout(lock_file, 100ms);
write_cache();
release_lock();
```

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->
**Benefits:**
- No repository churn from access tracking or computed metadata
- Fast retrieval of expensive computations
- Clean separation between user data and system metadata
- Simple crash recovery (cache is rebuildable)

**Tradeoffs:**
- Added complexity of cache invalidation logic
- Potential for stale reads in multi-process scenarios
- Small risk of data loss for in-flight session data on crash

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="🤖 AI/ADR-AI-002-gtd-kanban-integration.md">
---
id: ADR-AI-002
tags:
  - gtd
  - kanban
  - task-management
  - neovim
  - tui
  - inline-todos
status: accepted
depends_on: 
  - ADR-001
  - ADR-002
  - ADR-009
  - ADR-AI-001
created_date: 2025-08-30
last_modified: 2025-08-30
related_files: [src/commands/gtd.rs, src/tui/agenda.rs]
---

# ADR-AI-002-gtd-kanban-integration

## Objective
<!-- A concise statement explaining the goal of this decision. -->
Design a unified GTD/Kanban system that provides a command center view in Neovim while maintaining portability and simplicity in the underlying note format.

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->
Users need a centralized view of tasks, deadlines, and project status without leaving their note-taking environment. The vision is a Magit/org-agenda style interface showing:

- Upcoming deadlines and due items
- Inline TODOs extracted from note content  
- Kanban board for workflow visualization
- Collapsible project/schema groupings

Key requirements:
- Must parse inline TODO syntax: `TODO@HIGH: -[] implement feature`
- Support kanban workflow states without complex graph relationships
- Show completed items for configurable time period
- Integrate with LSP for checkbox state updates
- Maintain Obsidian compatibility

### Visual Mockup (human made)

  ```bash 
# Agenda
V ToDo ! 
	-[] TODO@HIGH: Critical parser bug | Note:[[IMP-005]] | Created: 2025-09-01
	-[] TODO@MED:  Refactor validation  | Note:[[IMP-005]] | Created: 2025-08-27
	-[] TODO: Default priority task | Note:[[IMP-003]] | Created: 2025-09-03
V Due_Dates
  - 2025-8-16: IMP-001 **OVERDUE!** # past due color coded red and gets a flag 
  - 2025-9-03: IMP-004 
V **Kanban**
	> Backlog
	V In-Progress
	  L IMP-004
	  L IMP-002 
	> Completed
	> Cancelled 

# Vault 
v **Templates** 
	1 - IMP-*  
	2 - ADR-*
	3 - ADR-AI-*
v **ADR** 
	- ADR-001-my-first-plan
	- ADR-002-my-happy-place
> **ADR-AI** 
v **IMP** 
	+ IMP-001-database-spike
	+ IMP-002-websocket-spike  
       
TAB: Collapse/Expand | RETURN: Select | SPACE+F: FuzzyFind | G: GraphView
  ```

## Decision
<!-- What is the change that we're proposing and/or doing? -->
Implement GTD through frontmatter fields and inline TODO parsing:

**Frontmatter extensions:**
```yaml
kanban_status: in_progress  # backlog|todo|in_progress|blocked|done|archived
due_date: 2025-09-01
kanban_statusline: "Optional human-readable status"
```

**Inline TODO syntax:**
```markdown
TODO@HIGH: -[] Critical bug fix
TODO@MED: -[] Refactor validation  
TODO: -[] Default priority task
```

**Display logic:**
- Completed items visible for 3 days by default
- TODOs colored by priority in Neovim (HIGH=red, MED=yellow, LOW=green)
- Kanban cards show inline TODOs from their linked notes
- Use cache layer for tracking completion timestamps without modifying notes
- The kanban_statusline is included on the agenda page if filled. 
  
  HumanNOTE(S): When displaying in the GUI we can hydrate with metadata from the index, what note was it tagged from, when was the tag added eg 
  	`- TODO@HIGH: -[] Critical parser bug | Note:[[IMP-005]] | Created: 2025-09-01`
    - The kanban_statusline is included on the agenda page if filled. The most idea is maybe it's cut off at X characters but scrolls on hoverover. Not sure the lift. 
    - The actual human typed entry could be like {TODO@MED} for max clarity. the we reuse that syntax as needed. 
    - A more verbose and specific syntax [{TODO@HIGH}: the note lives within the brackets.]
    - When the object is marked with the -[x] on the agenda screen the line in the document gets updated like ~~[{TODO@HIGH}: the note lives within the brackets.]~~ nothing is deleted just marked off. 
  
## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->
**Benefits:**
- Simple, scannable TODO syntax that works in any markdown viewer
- Kanban workflow without graph complexity
- Command center view achievable with existing frontmatter
- LSP can update checkboxes without touching frontmatter

**Tradeoffs:**
- True task dependencies require manual tracking
- No automatic completion percentage from subtasks
- Priority is encoded in TODO syntax, not frontmatter

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="🤖 AI/ADR-AI-003-extensible-graph-edges.md">
---
id: ADR-AI-003
tags:
  - graph
  - edges
  - frontmatter
  - validation
  - extensibility
status: accepted
depends_on: 
  - ADR-001
  - ADR-AI-001
  - ADR-AI-002
created_date: 2025-08-30
last_modified: 2025-08-30
related_files: [src/config.rs, src/validate.rs, src/graph.rs]
---

# ADR-AI-003-extensible-graph-edges

## Objective
<!-- A concise statement explaining the goal of this decision. -->
Create a unified abstraction for graph edge types that allows users to define custom relationships without code changes while maintaining consistent validation and traversal behavior across the system.

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->
The current system frontmatter approach requires manually defining each edge type (depends_on, blocked_by, etc.) with hardcoded validation logic. This creates several problems:

1. **Limited extensibility**: Adding new relationship types requires core code changes
2. **Inconsistent behavior**: Each edge type needs custom validation and graph traversal logic
3. **Use case constraints**: Different domains (ADR planning, RPG notes, project management) need different relationship vocabularies

Current multi-parent pattern works well:
```yaml
depends_on: [ADR-001, ADR-002, ADR-004]
```

But we need this pattern to work for arbitrary relationship types without hardcoding each one. The discussion showed the importance of flexible graph relationships for different use cases, while our own usage demonstrates that most relationships follow the same validation pattern: "ensure referenced nodes exist."

The system should work consistently whether someone defines `depends_on`, `blocked_by`, `character_knows`, or `implements` - they all follow the same node reference validation pattern.

## Decision
<!-- What is the change that we're proposing and/or doing? -->
Implement a three-tier frontmatter classification system that treats graph edges as a distinct, extensible category:

```toml
[schema.frontmatter]
# Explicitly defined system fields with special behavior
system_frontmatter = [
    "node_id",
    "created_date", 
    "last_modified",
    "groups",
    "kanban_status",
    "due_date"
]

# Graph edge fields - automatically validated as node references
graph_edges = [
    "depends_on",
    "blocked_by", 
    "implements",
    "supersedes",
    "parent_of"
    # Users can add more without changing core code
]

# Regular user fields
user_frontmatter = [
    "tags", 
    "status",
    "priority",
    "confidence_score"
]
```

**Automatic behaviors for graph_edges:**
- All values validated as existing node references
- Support both single values and arrays: `depends_on: ADR-001` or `depends_on: [ADR-001, ADR-002]`
- Included in graph traversal commands (`get --depth`, `graph`, `path`)
- Available for cycle detection and orphan analysis
- Indexed for fast lookup and reverse relationships

**Validation rules:**
```toml
[schema.validate.edges]
severity = "error"  # Default for all graph edges
validate_existence = true
allow_cross_schema = true
detect_cycles = true
```

Users can override per-edge:
```toml
[schema.validate.frontmatter.fields]
depends_on = { severity = "warning" }  # Override default
character_knows = { allow_cross_schema = false }  # Domain-specific rules
```

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->
**Benefits:**
- Users can define custom relationship types without core code changes
- Consistent validation behavior across all graph relationships  
- Single abstraction handles simple trees, complex DAGs, and domain-specific relationships
- Graph commands work automatically with new edge types
- Clear separation between temporal fields, relationships, and user metadata

**Tradeoffs:**
- Three-tier system adds conceptual complexity over simple system/user split
- Graph edge fields can't have arbitrary validation (all follow node reference pattern)
- Migration required for existing schemas using hardcoded edge validation

**Examples enabled:**
```yaml
# Project management
depends_on: [ADR-001]
blocked_by: [IMP-003]
implements: [SPEC-002]

# RPG worldbuilding  
character_knows: [NPC-Gandalf, NPC-Aragorn]
location_contains: [ITEM-Ring, NPC-Sauron]
quest_requires: [ITEM-Sword, SKILL-Stealth]
```

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-001-cli-rag.toml.md">
---
id: ADR-001
tags:
  - config
  - toml
  - cli
  - north-star
status: accepted
depends_on:
created_date: 2025-08-24
last_modified: 2025-08-30
related_files:
  - .cli-rag.toml
---

# cli-rag.toml

## Objective
<!-- A concise statement explaining the goal of this decision. -->

At the time of writing this document is **aspirational** and is not in line with the actual codebase. The intention of this effort is to create a north star that explains the UX vision for the application. 

The .toml is designed to be very extensible but we will create a [[ADR-010-the-LUA-escape-hatch]] escape hatch for highly custom use-cases. 
  
## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

### Example `cli-rag.toml` Block 

if we see issues we can add an option to shard the index but i don't instantly think it's likely; 

```toml
[scan.index]
strategy = "sharded"
shard_by = "schema"  # Separate AIM-*, ADR-*, etc.
max_shard_size_mb = 10
```

famous last words. 


```TOML
[[config]]
#: =============================================================================
#:                            # --- Version --- #
#: =============================================================================
#: Sets the config version for all top level rules. All imported notes inherit
#: the same version.
#: An individual `[[schema]`] can call this to remain on an older version
config_version = 0.1

#: =============================================================================
#:                            # --- SCAN --- #
#: =============================================================================
#: Settings related to discovery, filepaths, and scan process
[config.scan]
#: The root directories that cli-rag will scan for notes.
#: All paths must be relative to the location of this `.cli-rag.toml` file.
#: Defaults to the current directory ["."] if left empty.
filepaths = ["file/path", "file/other/path"]
#: By default, an index will be created at '.cli-rag/rag-index.json'.
#: This can be given an arbitrary override.
#: File paths are relative to the location of this `.cli-rag.toml` file.
index_path = "alternate/filepath/rag-index.json"
#: `hash_mode` controls HOW the tool detects if a file has changed.
#: Defaults to `mtime`.
#: +-----------+-----------------------------------------------------------+
#: |  `mtime`  |   Fast but less accurate.                                 |
#: |           |   Compares the file's "last modified" timestamp.          |
#: +-----------+-----------------------------------------------------------+
#: | `content` |  100% Accurate but slower.                                |
#: |           |  Computes a hash of the entire file's content.            |
#: +-----------+-----------------------------------------------------------+
hash_mode = "mtime"
#: `index_strategy` controls what is stored in the index for search.
#: Defaults to content.
#: +------------+----------------------------------------------------------+
#: | `metadata` | Fastest option. Stores only front matter and links.      |
#: +------------+----------------------------------------------------------+
#: | `content`  | (Full-Text Search) Stores all metadata AND the           |
#: |            | full text of every note.                                 |
#: +------------+----------------------------------------------------------+
index_strategy = "content"
#tuning for large repos 
# parallel_workers = 4
# cache_strategy = "aggressive"
#: Remove directories or patterns from scanning to improve speed.
#: Patterns are relative to the location of this `.cli-rag.toml` file.
ignore_globs = ["**/node_modules/**", "**/dist/**"]

#: =============================================================================
#:                            # --- AUTHORING --- #
#: =============================================================================
#: Settings related to creating and editing notes
[config.authoring]
#: The editor to launch for new or existing notes.
#: Uses $EDITOR or $VISUAL if not set.
editor = "neovim"
#: runs the `watch` command as a background process for live updates when
#: the neovim plugin is open and active.
background_watch = true

#: =============================================================================
#:                             # --- GRAPH --- #
#: =============================================================================
#: Default settings for graph traversal commands (get, graph, path)
[config.graph]
#: Default depth for traversing dependencies.
depth = 2
#: Whether to include dependents (backlinks) in traversals.
include_bidirectional = true

#: =============================================================================
#:                            # --- RETRIEVAL --- #
#: =============================================================================
#: Default settings for content retrieval commands (get, groups)
[config.retrieval]
#: Whether to include the full markdown content in the output.
include_content = true

#: =============================================================================
#:                        # --- TEMPLATE MANAGEMENT --- #
#: =============================================================================
#: For a cleaner .`cli-rag.toml` it's advised to import an external schema.
#: Alternatively one or more `[[schema]]` may be defined inline below
[config.templates]
import = [".cli-rag/templates/ADR.toml", ".cli-rag/templates/RPG.toml"]

#: =============================================================================
#:                            # --- SCHEMA --- #
#: =============================================================================
#: 1. Define `[[schema]]` blocks to create a note type. Assign a `name`.
#: 2. (Optional) Pin a `config_version` to prevent breaking changes.
#: 2. Set one or more `file_patterns` for discovery.
#: 3. Define the rules for filename generation.
#: 5. Use `template` to define the full structure of the final note.
#: 6. Define the custom and system frontmatter if present.
```

### Templates 

#### ID Defined Schema(s)

```toml
#: =============================================================================
#:                                # --- SCHEMA --- #
#: =============================================================================
#: 1. Define `[[schema]]` blocks to create a note type. Assign a `name`.
#: 2. (Optional) Pin a `config_version` to prevent breaking changes.
#: 3. Set one or more `file_patterns` for discovery.
#: 4. Define the rules for filename generation.
#: 5. Use `template` to define the full structure of the final note.
#: 6. Define the custom and system frontmatter if present.
#: 7. Define custom validation rules using `schema.validate`.

[[schema]]
name = "ADR"
#: =============================================================================
#:                            # --- Version --- #
#: =============================================================================
#: Sets the config version for all top level rules.
#: If not set this is inherited from `.cli-rag.toml`
config_version = 0.1
#: =============================================================================
#:                           # --- DISCOVERY --- #
#: =============================================================================
#: Set discovery rules for notes types. Accepts globs/regex.
#: Notes must be under your defined filepaths in `.cli-rag.toml` to be discovered.
file_patterns = ["ADR-*.md", "ADR-DB-*.md"]

#: =============================================================================
#:                     # --- TEMPLATES & GENERATION --- #
#: =============================================================================
#: The `[schema.new]` block configures the `new` command and defines how
#: notes are generated.
#: This block configures both how the note is tracked and what template is used.
#: If no `id_generator`is defined the note will be tracked by filename.
#: The `filename_template` defines the structure for the output filename.
#:
#:                    #--- FILENAME TEMPLATE BUILDER --- #
#:   Advanced rules for creating custom titles when using the 'new' command
#: +-------------------+-------------------------------------------------------+
#: |        Filter     |                   Description                         |
#: +-------------------+-------------------------------------------------------+
#: | `{{title}}`       |  Injects the string from the --title flag.            |
#: +-------------------+-------------------------------------------------------+
#: | `{{id}}`          |  Injects the stable ID from the id_generator.         |
#: |                   |  Use only if the `id_generator` is defined.           |
#: +-------------------+-------------------------------------------------------+
#: | `{{schema.name}}` |  Injects the name of the schema. Used as-is.          |
#: +-------------------+-------------------------------------------------------+
#: | `{{now}}`         |  Injects system time. Default = ISO 8601              |
#: +-------------------+-------------------------------------------------------+
#:
#:                       # --- Modifier Rules --- #
#: +-----------------------+--------------------------------------------------+
#: |        Filter         |                    Example                       |
#: +-----------------------+--------------------------------------------------+
#: |` kebab-case `         | {{title|kebab-case}} --> "my-new-feature"        |
#: +-----------------------+--------------------------------------------------+
#: | `snake_case`          | {{title|snake_case}} --> "my_new_feature"        |
#: +-----------------------+--------------------------------------------------+
#: | `SCREAMING_SNAKE_CASE`| {{title|SCREAMING_SNAKE_CASE}} -->               |
#: |                       | "MY_NEW_FEATURE"                                 |
#: +-----------------------+--------------------------------------------------+
#: | `camelCase`           | {{title|camelCase}} --> "myNewFeature"           |
#: +-----------------------+--------------------------------------------------+
#: | `PascalCase`          | {{title|PascalCase}} --> "MyNewFeature"          |
#: +-----------------------+--------------------------------------------------+
#: | `date:"<strftime>"`   | {{now \| date:"%Y-%m-%d"}} -> "2025-08-26"       |
#: +-----------------------+--------------------------------------------------+
[schema.new]
#: Define the name template for the `new` command. unset = filename
id_generator = { strategy = "increment", prefix = "ADR-" padding = "3" }
#: Options are ["increment", "datetime", "uuid"]
#: Prefix is not mandatory if using the later two options
filename_template = "{{id}}-{{title|kebab-case}}.md"

#: =============================================================================
#:                           # --- TEMPLATES --- #
#: =============================================================================
#: Manually defined frontmatter via the template are not tracked by `validate`.
#: The variables listed below are injected by the `new` command.
#: 
#:                       # --- TEMPLATE VARIABLES --- #
#: +-----------------+---------------------------------------------------------+
#: | {{id}}          | Inject the `ID` field as defined by `id_generator`.|
#: |                 | Fallsback to filename.                                  |
#: +-----------------+---------------------------------------------------------+
#: | {{title}}       | Inject the title provided via the `--title <T>` flag    |
#: |                 | on the `new` command.                                   |
#: +-----------------+---------------------------------------------------------+
#: | ((frontmatter)) | Inject items within the `schema.frontmatter` table into |
#: |                 | the template                                            |
#: +-----------------+---------------------------------------------------------+
#: | {{LOC|100}}     | Set the maximum number of lines per heading.            |
#: +-----------------+---------------------------------------------------------+
#: | {{date}}        | Today's date. **Default format:** `YYYY-MM-DD`.         |
#: +-----------------+---------------------------------------------------------+
#: | {{time}}        | Current time. **Default format:** `HH:mm`.              |
#: +-----------------+---------------------------------------------------------+
[schema.new.template]
[schema.new.template.prompt]
template = """
# Instructions
**Generate an Architectural Decision Record based on the user's request.**
- Fill out the template below exactly as provided.
- For the 'status' field, you MUST use one of the following values:
- [draft, proposed, accepted, superseded, cancelled].
- For the 'tags' field, provide a comma-separated list of relevant technical tags.
- Fill in the content for each heading (Objective, Context, etc.) based on the user's goal.
"""
[schema.new.template.note]
template = """
((frontmatter))

# {{filename}}

## Objective
<!-- A concise statement explaining the goal of this decision. -->
{{LOC|50}}

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->
{{LOC|300}}

## Decision
<!-- What is the change that we're proposing and/or doing? -->
{{LOC|50}}

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->
{{LOC|50}}

## Updates
<!-- Changes that happened when the rubber met the road -->
{{LOC|100}}
"""

#: =============================================================================
#:            # --- ADVANCED: CUSTOM TEMPLATE GENERATOR --- #
#: =============================================================================
#: Use the OpenAPI contract to write a custom lua template manager. Buyer Beware. 
# lua_generator = "path/to/script.lua"


#: =============================================================================
#:                        # --- ~.FRONTMATTER  --- #
#: =============================================================================
#: Frontmatter can be "System" or "User".
#: Named Graph edges can be defined as well. 
#: Only frontmatter defined below will be tracked by the `validate` command.
#: 
#:                      # --- FRONT MATTER SYLES --- #
#: +-----------------------+---------------------------------------------------+
#: | `system_frontmatter`  | Runs pre-configured logic against YAML            |
#: |                       | frontmatter. See table below.                     |
#: +-----------------------+---------------------------------------------------+
#: | `user_frontmatter`    | Define arbitrary YAML frontmatter. Validation     |
#: |                       | logic can be created via String, Glob or regex.   |
#: +-----------------------+---------------------------------------------------+
#: | `graph_edges`         | Define all tracked/labeled graph edges for the    |
#: |                       | DAG. Will error if ID does not exist in index.    |
#: +-----------------------+---------------------------------------------------+
#: | `~.frontmatter.GTD`   | System frontmatter that triggers inclusion on     |
#: |                       | the main screen on neovim and the GTD command     |
#: +-----------------------+---------------------------------------------------+
#:
#:                      # --- SYSTEM_FRONTMATTER --- #
#: +-----------------+---------------------------------------------------------+
#: | `node_id`       | Defines the note on the DAG using `id_generator`.       |
#: +-----------------+---------------------------------------------------------+
#: | `created_date`   | Updates the note with system time when using `new`      |
#: +-----------------+---------------------------------------------------------+
#: | `last_modified` | if `watch` is active the note will be updated with a    |
#: |                 | new modified time on edit                               |
#: +-----------------+---------------------------------------------------------+
#: | `groups`        | Defines subgroups for note types. These can generate a  |
#: |                 | human/AI readable Index                                 |
#: +-----------------+---------------------------------------------------------+
#:
#:                      # --- `~.frontmatter.GTD` --- #                         
#: +-----------------+---------------------------------------------------------+
#: | `kanban_status` | Define Kanban status. Deplayed on Agenda screen. Provide|
#: |                 | a table of legal statuses.                              |
#: +-----------------+---------------------------------------------------------+
#: | `kanban_        | Define a status line that shows under the kanban staus  | 
#: | statusline`     | on the agenda screen. true or false. `default = "false"`|
#: +-----------------+---------------------------------------------------------+
#: | `due_date`      | Set a due date. Appears on neovim agenda x days prior.  | 
#: |                 | true or false to enable.                                |
#: +-----------------+---------------------------------------------------------+
  
[schema.frontmatter]
 # Explicitly defined system fields with special behavior
system_frontmatter = [
 "node_id",
 "created_date",
 "last_modified",
 "groups",
 ]

# Regular user fields
user_frontmatter = [
  "tags",
  "priority",
  "confidence_score"
  ]

# Graph edge fields - automatically validated as node references
graph_edges = [
  "depends_on",
  "blocked_by",
  "supersedes",
  # Additional edges can be defined freely. 
  ]

[schema.frontmatter.GTD] 
kanban_status = [ 
  "backlog", 
  "planned", 
  "in-progress", 
  "completed",
  "cancelled"
  ]
kanban_statusline = true
due_date = true

#: =============================================================================
#:                           # --- VALIDATION --- #
#: =============================================================================
#: This block configures the `validate` command largely using globs and regex.
#: Construct your configuration using the options below.
#: 
#:                         # --- VALIDATORS KEYS --- #
#: +---------------------------------+--------------------+---------------------+
#: | Validator Table                 | Configuration Key  | Description/Options |
#: +---------------------------------+--------------------+---------------------+
#: | [schema.validate]               | Top level config inherited to all tables |
#: |                                 |--------------------+---------------------|
#: |                                 | `severity`         | accepts "error"     |
#: |                                 |  (all tables)      | "warning", "ignore" |
#: +---------------------------------+--------------------+---------------------+
#: | [schema.validate.frontmatter]   | Top most Table for frontmatter config    | 
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.frontmatter.allow_unknown] | Determine behavior for undefined         |
#: |                                 | frontmatter                              |
#: |                                 |--------------------+---------------------|
#: |                                 | `allow_unknown`    | Policy for extra    |
#: |                                 |                    | fields.             |
#: |                                 |                    | Options: "true",    |
#: |                                 |                    | "false",            |
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.frontmatter.fields]        | Custom rules against `user_frontmatter`  |
#: |                                 |------------------------------------------|
#: |                                 | `regex`            | A single regex      |
#: |                                 |                    | string.             |
#: |                                 +--------------------+---------------------+
#: |                                 | `enum`             | An array of exact   |
#: |                                 |                    | string matches.     |
#: |                                 +--------------------+---------------------+
#: |                                 | `globs`            | An array of glob    |
#: |                                 |                    | patterns.           |
#: |                                 +--------------------+---------------------+
#: |                                 | `float`            | A table with        |
#: |                                 |                    | optional `min` and  |
#: |                                 |                    | `max` float values. |
#: |                                 +--------------------+---------------------+
#: |                                 | `integer`          | A table with        |
#: |                                 |                    | optional `min` and  |
#: |                                 |                    | `max` float values. |
#: +---------------------------------+--------------------+---------------------+
#: | [schema.validate.body]          | Top most Table for body validation       |
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.body.headings]             | Various body Validation settings         |
#: |                                 |------------------------------------------|
#: |                                 | `heading_policy`   | How to check heads. |
#: |                                 |                    | Options: "strict",  |
#: |                                 |                    | "missing_only",     |
#: |                                 |                    | "ignore".           |
#: |                                 |--------------------+---------------------+
#: |                                 | `max_count`        | INT.Maximum Nunmber |
#: |                                 |                    | of headings allowed |
#: |                                 |                    | in a document.      |
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.body.line_count]           | Prevents the LLM from outputting over    |
#: |                                 | `x` LOC                                  |
#: |                                 |--------------------+---------------------|
#: |                                 | `scan_policy`      | When to run check.  |
#: |                                 |                    | Options:            |
#: |                                 |                    | "on_creation",      |
#: |                                 |                    | "on_validate".      |
#: +---------------------------------+--------------------+---------------------+
#: | [schema.validate.edges]         | Top level most for all graph config      | 
#: |                                 |------------------------------------------|
#: |                                 | `required_edges`   | Define if an edge   |
#: |                                 |                    | is MUST be set      |
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.edges.wikilinks]           | Rules covering [[obsidian style]] links  |
#: |                                 |------------------------------------------|
#: |                                 | `min_outgoing`     | Int. Min required   |
#: |                                 |                    | [[wikilinks]] out.  |
#: |                                 |--------------------+---------------------+
#: |                                 | `min_incoming`     | Int. Min required   |
#: |                                 |                    | [[wikilinks]] in.   |
#: +---------------------------------+--------------------+---------------------+
#: | ↳ [~.edges.cross_schema]        | Rules for mutli schema DAGs.             |
#: |                                 |------------------------------------------|
#: |                                 | `allowed_targets`  | Define if graph     |
#: |                                 |                    |edges traverse schema|
#: +---------------------------------+--------------------+---------------------+
#: | [schema.validate.GTD]           | Top level table for all GTD config       |
#: |                                 |--------------------+---------------------|
#: |                                 | `enable_TODO`      | Determine if TODO   |
#: |                                 |                    | will be scanned on  |
#: |                                 |                    | notes. true/false   |
#: |                                 |--------------------+---------------------|
#: |                                 | `enable_kanban`    | Determine if Kanban |
#: |                                 |                    | will be scanned on  |
#: |                                 |                    | notes. true/false   |  
#: |                                 |--------------------+---------------------|
#: |                                 | `enable_kanban     | Determine if Kanban |
#: |                                 | statusline`        | status will be used |     
#: |                                 |                    | for the agenda. T/F |   
#: |                                 |--------------------+---------------------|
#: |                                 | `due_date_warning` | due dates will show |
#: |                                 |                    | on the agenda screen|     
#: |                                 |                    | when due in X days. |   
#: |                                 |--------------------+---------------------|
#: |                                 | `detect_cycles`    | enable or disable   |
#: |                                 |                    | cycle detection.    |     
#: |                                 |                    | true or false.      |   
#: +----------------------------------------------------------------------------+
[schema.validate]
severity = "error" # Default severity for all validate rules

#: =============================================================================
#:                   # --- ADVANCED: CUSTOM VALIDATOR --- #
#: =============================================================================
#: Use the OpenAPI contract to write a custom lua validator. Buyer Beware. 
# lua_validator = "path/to/script.lua"

#: =============================================================================
#:                     # --- VALIDATOR: FRONTMATTER --- #
#: =============================================================================
[schema.validate.frontmatter]
[schema.validate.frontmatter.allow_unknown]
#: Policy for fields not explicitly listed in `custom_frontmatter` 
#: or `validated_frontmatter`.
#: default = true
allow_unknown = true
severity = "warning" # Overrides default 
#:  --- Field-specific Rules ---  :#
[schema.validate.frontmatter.fields]
id     = { regex = "^ADR-\\d{3}$" }
tags   = { regex = "^[^\\n]*$", severity = "warning" } 
related_files = { regex = ["\\.exs?$", "\\.py$", "\\.js$", "\\.md$", "\\.toml$"] }
depends_on = { globs = ["ADR-*", "ADR-DB-*"], severity = "warning" } 
blocked_by = { globs = ["ADR-*", "ADR-DB-*"], severity = "warning" } 
priority = { integer = { min = 0, max = 100 } 
confidence_score = { float = { min = 0.0, max = 1.0 }, severity = "error" }

#: =============================================================================
#:                       # --- VALIDATOR: BODY --- #
#: =============================================================================
[schema.validate.body]
[schema.validate.body.headings]
#: Policy for matching headings against the note template.
#: Options: [
#: "exact" (exact match), "missing_only" (template headings requiured
#: + additional headings are allowed), "ignore"
#: ]
heading_check = "missing_only"
max_count = 10 
severity = "warning" # Override default 
[schema.validate.body.line_count]
#: When to perform this check.
#: define using {{LOC|`X`}} in the template manager.
#: This set the number of lines **per heading**
#: Options: "on_creation", "on_validate".
scan_policy = "on_creation"

#: =============================================================================
#:                      # --- VALIDATOR: EDGES --- #
#: =============================================================================
[schema.validate.edges]
#: All edges will be added to front matter but only the following will cause 
#: errors if unset. 
required_edges = ["depends_on"]
detect_cycles = true
[schema.validate.edges.wikilinks]
severity = "warning"
min_outgoing = 1
min_incoming = 0
[schema.validate.edges.cross_schema]
# Define schema's that may be be set as a DAG edge. 
allowed_targets = ["ADR", "IMP", "ADR-AI"]

#: =============================================================================
#:                       # --- VALIDATOR: GTD --- #
#: =============================================================================
[schema.validate.GTD]
# Determine if {TODO@high}: note content is tracked and added to the agenda  
enable_TODO = true
# Determine if the kanban yaml is tracked and added to the agenda  
enable_kanban = true
# Determine if statusline is added to agenda, if present. 
enable_kanban_statusline = true
# Items will be added to the agenda when due in X days. Accepts ints. 
due_date_warning = 5 
severity = "warning"
```

## Tech Details 

### In-Scope 
- We can force Titles to the correct case using either `heck` or `convert_case`. 
- We should ship with a folder with a few example schema's that users can modify or use directly before 1.0. This is the escape hatch so you can use the tool for a bit and decide if it's even worth setting up a config file.	  
- for speed connections, backlinks etc need to be tracked in the index. 
- the groups and file index have been collapsed to a single item vs the current codebase. We also no longer allow multiple indexes in a single repo.  

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Tentatively adopt the above framework in full with WASM accepted but deferred as future scope. Exact details will be determined in implementation.  

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

A new implementation ticket will be created to capture the remedial work needed to align the codebase with the above "north star" in a form of configuration driven development.
</file>

<file path="ADR-002-Visual-Mode-planning.md">
---
id: ADR-002
tags:
  - TUI
  - NeoVIM
  - rataTUI
status: draft
depends_on:
  - ADR-01
  - ADR-003
created_date: 2025-08-28
last_modified: 2025-08-28
related_files: []
---

# Visual-Mode-planning

## Objective
<!-- A concise statement explaining the goal of this decision. -->


## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

### TUI/NeoVim Workflow Planning

1. The user opens a new repo and types `cli-rag init` which checks for a .cli-rag.toml and if not present opens their editor with a marked up config file. They can either save this or exit the process. 
   
   See [[ADR-001-cli-rag.toml]] for a full example. 

2. Once the .cli-rag.toml is created it opens the TUI "master control" screen e.g. Magit/org style tab collapsible lists. This expands as tracked notes are added. 
   
  ```bash 
# Agenda
V ToDo ! 
	-[] TODO@HIGH: Critical parser bug | Note:[[IMP-005]] | Created: 2025-09-01
	-[] TODO@MED:  Refactor validation  | Note:[[IMP-005]] | Created: 2025-08-27
	-[] TODO: Default priority task | Note:[[IMP-003]] | Created: 2025-09-03
V Due_Dates
  - 2025-8-16: IMP-001 **OVERDUE!** # past due color coded red and gets a flag 
  - 2025-9-03: IMP-004 
V **Kanban**
	> Backlog
	V In-Progress
	  L IMP-004
	  L IMP-002 
	> Completed
	> Cancelled 

# Vault 
v **Templates** 
	1 - IMP-*  
	2 - ADR-*
	3 - ADR-AI-*
v **ADR** 
	L ADR-001-my-first-plan
	L ADR-002-my-happy-place
> **ADR-AI** 
v **IMP** 
	L IMP-001-database-spike
	L IMP-002-websocket-spike  
       
TAB: Collapse/Expand | RETURN: Select | SPACE+F: FuzzyFind | G: GraphView
```

- This may not be possible in neovim vs emacs but the ideal is being able unfold the note directly into an editable minibuffer or hit enter to open the full note.  

3.  The user can begin creating notes populated with expected (empty) frontmatter and template. Selecting a note or a template opens the editor for the user. When the close the editor the TUI catches the exit code and rebuilds the index and adds the new tracked notes to the master control screen. 

4. Ideally we would have a simple fuzzy finder that is accessible in all windows with the same keystrokes. It only indexes tracked notes. This and the master control screen let you fly around the knowledge base. 
   
5. GraphView the leans on graphviz dot view's ability to render out ascii. Could use the search command and let the user navigate the graph by pulling different clusters 
   
```
   An idea that keeps coming to mind is using the local `--include-bidirectional` graph as a navigation system in the TUI/NVIM. 

[Notably, graphiz directly supports ascii output.](https://graphviz.org/docs/outputs/ascii/) An imaginable workflow is we pull a local graph and append the ID's so it's 

1. ADR-001 
2. ADR-002 
   
You are then shown a screen like this where you can with a single key press to fly around notes e.g. 


     ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
     ╎             adr             ╎
     ╎                             ╎
     ╎ ┌─────────┐     ┌─────────┐ ╎       ┌─────────┐
  ┌─ ╎ │ ADR-001 │ ◀── │ ADR-000 │ ╎ ◀──   │  start  │
  │  ╎ └─────────┘     └─────────┘ ╎       └─────────┘
  │  ╎   │               ▲         ╎         │
  │  ╎   │               │         ╎         │
  │  ╎   │               │         ╎         ▼
  │  ╎   │               │         ╎     ┌−−−−−−−−−−−−−┐
  │  ╎   │               │         ╎     ╎     imp     ╎
  │  ╎   ▼               │         ╎     ╎             ╎
  │  ╎ ┌─────────┐       │         ╎     ╎ ┌─────────┐ ╎
  │  ╎ │ ADR-002 │       │         ╎     ╎ │ IMP-001 │ ╎
  │  ╎ └─────────┘       │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │               │         ╎     ╎ ┌─────────┐ ╎
  │  ╎   │               │         ╎     ╎ │ IMP-002 │ ╎
  │  ╎   │               │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │             ┌─────────┐ ╎     ╎ ┌─────────┐ ╎
  │  ╎   └───────────▶ │ ADR-003 │ ╎ ◀── ╎ │ IMP-003 │ ╎
  │  ╎                 └─────────┘ ╎     ╎ └─────────┘ ╎
  │  ╎                             ╎     ╎   │         ╎
  │  └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘     ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   ▼         ╎
  │                      │               ╎ ┌─────────┐ ╎
  └──────────────────────┼─────────────▶ ╎ │ IMP-004 │ ╎
                         │               ╎ └─────────┘ ╎
                         │               ╎             ╎
                         │               └−−−−−−−−−−−−−┘
                         │                   │
                         │                   │
                         │                   ▼
                         │                 ┌─────────┐
                         └─────────────▶   │   end   │
                                           └─────────┘
```


   
### Implementation Details 

- RataTUI or neovim is the most likely front-end here. 
- The `watch` command is active while the TUI is running unless toggled off via a .toml flag. 
- the TUI fuzzy finder is not a full telescope redo --it's just a magit style wrapper of `search --query `
   
### The NeoVim Advantage

All of the above can be much smoother in neovim. In theory we could 

- Define a consistent naviation UI using a leader key. 
- Lean on Existing fuzzy finding and implement less ourselves. 
- Offer a first class editing experience. We could in theory parse our index and have tree-sitter powered live linting of valid id's and note names
- make `[[links]]` and ID: ADR-005 directly navigable from the editor. 

This is ultimately inching much closer to a AI Co-Programmer friendly obsidian that lives in a repo without fuss. I'm not sure if that's a good or a bad thing. It would without a doubt be the most comfortable and fully featured version. 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Prioritize neovim. While the TUI is nice and more universal the neovim community is the space that makes sense for a lua configured programmers tool. its likely to be 

1. less work. 
2. more powerful. 

Also i want it to be fennel ))))))))))))))))))))))))))))))))))

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

plan to adopt `nvim-oxi` and ensure our patterns do not contradict this future goal. It may be v1 or v1.1 but priority is fairly high. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-003a-CLI-refactor-planning.md">
---
id: ADR-003a
tags:
  - cli
  - refactor
status: accepted
depends_on:
  - ADR-001
  - ADR-004
created_date: 2025-08-24
last_modified: 2025-08-25
related_files:
  - ~/cli-rag/src/commands
---

# ADR-004-CLI-refactor-planning

## Objective
<!-- A concise statement explaining the goal of this decision. -->

Until this point CLI-RAG has grown adhoc out of a a dog-fooded .js script. As the workflow is becoming more clear the existing commands should be reviewed and adjusted to ensure everything is coherent. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

The current command list 
- `init` — Create `.adr-rag.toml` in the current repo and open it in an editor by default. Flags:
    - `--force` overwrite if exists
    - `--print-template` print template to stdout
    - `--silent` do not open the config after creating/detecting it
- `doctor` — Show resolved config, bases, discovery mode (index vs scan), and quick stats.
    - Reports per-type counts when schemas are defined, and unknown-key stats.
    - JSON: use global `--format json`.
- `search --query <substr>` — Fuzzy search by ID/title across discovered ADR files.
- `topics` — List semantic groups derived from front matter (`groups` in ADRs).
- `group --topic "<name>" [--include-content]` — Show ADRs in a group; optionally include full content.
- `get --id ADR-021 [--include-dependents]` — Print an ADR with dependencies (and dependents if requested).
- `cluster --id ADR-021 [--depth N] [--include-bidirectional]` — Traverse dependencies (and dependents) to depth.
- `graph --id ADR-021 [--depth N] [--include-bidirectional] [--format mermaid|dot|json]` — Export a dependency graph around an ADR.
- `path --from ADR-011 --to ADR-038 [--max-depth N]` — Find a dependency path if any.
- `validate [--format json] [--dry-run] [--full-rescan] [--write-groups]` — Validate front matter/refs; on success writes indexes (unless `--dry-run`).
- Incremental by default: only reparses changed files using mtime/size. Use `--full-rescan` to force scanning all.
- Exits non-zero if validation fails.
- `watch [--debounce-ms 400] [--dry-run] [--full-rescan]` — Watch bases for changes and incrementally validate + update indexes.
- Debounces rapid events; writes on success (unless `--dry-run`).

## Decision
<!-- What is the change that we're proposing and/or doing? -->

### The Universal Flag

#### `--format Plain|Json|Ndjson`

All command EXCEPT for `graph` will accept a `--format` flag. This is designed for integrating the library with tooling and the eventual Model Context Protocol Server. 

### The Essential Functions 

#### Init 
Create `.adr-rag.toml` in the current repo and open it in an editor by default.

**Flags** 
- `--silent`: Write the default template directly to disk without opening the config in the editor 
- `--force`: Overwrite `.cli-rag.toml` even if it exists
- `--print-template`: Print template to stdout

#### validate 
Lint's notes based on the various `[[schema]]` configured in `.cli-rag.toml`. By default all index scans are incremental reparse's using `mtime` and `size`. Exits with an error code in the event validation fails. Writes out `index_relative` unless `--dry-run` is used.
  
**Flags** 
- `--dry-run`: Validate the index and print errors without writing or updating the index on disk. Prints errors or success. 
- `--full-rescan`: Scans all files regardless of tracked `mtime` or `size`
- `--write-groups`: Write out only `groups_relative` and updates `semantic-groups.json`. This requires an active schema with `validated_frontmatter` and `groups` active.  
- `--write-all`: Write out both `groups_relative` and `index_relative`. 

#### new 
The primary tool for creating a new note. Can open the defined editor with the `--edit` flag 
  
**Flags**
- `--schema <S>`: Select a .toml defined schema to use as a template. 
- `--title <T>`: Create a new note defined by Title. 
- `--id <I>`: Create a new note defined by ID. 
- `--edit`: Open the note in the defined editor. 

---

#### watch 
Watches filepaths for changes and incrementally validates & update the indexes. Debounces rapid events; writes on success (unless `--dry-run`).

**Flags**
- `[--debounce-ms 400]`: Set custom debounce time. 
- `[--dry-run]`: Watches file changes but does not write to the index. 
- `[--full-rescan]`: Fully scans all tracked paths and updates the index. 
  
  ```markdown 
  - when watching, ignore temp/lockfiles (`**/*~`, `**/.#*`, `**/*.tmp`) and editor swap dirs.
  ```

### The Syntactic Sugar

#### doctor 
Show resolved config, filepaths, discovery mode (index vs scan), and quick stats. Reports per-type counts when schemas are defined, and unknown-frontmatter stats.

#### search --query `<substr>`

Fuzzy search by ID/title across tracked notes.

**Flags**
- `--schema <S>`: Search only one defined schema 

#### path --from ABC --to XYZ 
Returns the shortest dependency path between two notes or throws and error if none exist.
  
**Flags**
- `[--max-depth N]`: Set maximum number of recursive notes the path will traverse. 
  
  
### Problematic/Underdeveloped User Story

#### group

```markdown 
##### topics
- List semantic groups derived from frontmatter (`groups` in ADRs).

##### group 
`[--topic "<name>"] [--include-content]` 
- Show ADRs in a group; defaults to full content.
```

These tools are currently not logically implemented and are are holdover from the original `masterplan-validate.js` this library was built out of. The issue is currently we do not have a clear user story around how these groups would be created or defined. 

The purpose of this tool is primarily to give an AI agent a map to understand the code-base. 

One option would be to define `groups` as `validated_frontmatter` with hard-coded logic in the [[ADR-001-cli-rag.toml]];

```toml
# --- `validated_frontmatter` are built tools that will run validation logic beyond simply checking if it exist and has content --- 
# |-----------------|--------------------------------------------------------------------------------|
# |  `depends_on`   | validates the id exists and is valid or throws and error                       |
# |-----------------|--------------------------------------------------------------------------------|
# | `created_date`  | Updates the note with system time when created using the `new` command         |
# |-----------------|--------------------------------------------------------------------------------|
# | `last_modified` | if `watch` is active the note will be updated with a new modified time on edit |
# |-----------------|--------------------------------------------------------------------------------|
# |     `groups`     | Defines subgroups for note types. These can generate a human/AI readable Index |
# |-----------------|--------------------------------------------------------------------------------|
validated_frontmatter = ["depends_on", "created_date", "last_modified", "group"]
```

This would allow the user to dynamically define groups as required. 

The second issue is the split name for `topics` and `groups` is not especially intuitive or ergonomic. Maybe it could be arranged in a single command like so; 

##### groups
lists tracked notes organized by `groups` frontmatter. If the frontmatter is not active this will throw errors. 

**Flags**
- `--list`: print all semantic groups tracked by `validated_frontmatter` on the current graph.

---

#### graph

```markdown
##### graph 
`[--id ABCD] [--depth N] [--include-bidirectional] [--format mermaid|dot|json]`
- Export a dependency graph around an ADR.
```

There are two places the graph tool currently introduces uncertainty. 

Firstly the `--format` command collides with the global `--format plain|json|ndjson` formatting command. This should be changed eg `--graph-output`. This is a relatively minor concern. 

The deeper concern is just "Is this actually useful?" It's pretty commonly agreed that the graphview in discord is more visual fun and games than something truly productive and useful. There is a chance this is just not a feature that's a large value add (even if it's like, neat, and i want to see it.)

The thing that jump out is that it makes seeing "orphan" notes trivial. That said, we can just surface this information in doctor as well. 

An idea that keeps coming to mind is using the local `--include-bidirectional` graph as a navigation system in the TUI/NVIM. 

[Notably, graphiz directly supports ascii output.](https://graphviz.org/docs/outputs/ascii/) An imaginable workflow is we pull a local graph and append the ID's so it's 

1. ADR-001 
2. ADR-002 
   
You are then shown a screen like this where you can with a single key press to fly around notes e.g. 

```ascii
     ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
     ╎             adr             ╎
     ╎                             ╎
     ╎ ┌─────────┐     ┌─────────┐ ╎       ┌─────────┐
  ┌─ ╎ │ ADR-001 │ ◀── │ ADR-000 │ ╎ ◀──   │  start  │
  │  ╎ └─────────┘     └─────────┘ ╎       └─────────┘
  │  ╎   │               ▲         ╎         │
  │  ╎   │               │         ╎         │
  │  ╎   │               │         ╎         ▼
  │  ╎   │               │         ╎     ┌−−−−−−−−−−−−−┐
  │  ╎   │               │         ╎     ╎     imp     ╎
  │  ╎   ▼               │         ╎     ╎             ╎
  │  ╎ ┌─────────┐       │         ╎     ╎ ┌─────────┐ ╎
  │  ╎ │ ADR-002 │       │         ╎     ╎ │ IMP-001 │ ╎
  │  ╎ └─────────┘       │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │               │         ╎     ╎ ┌─────────┐ ╎
  │  ╎   │               │         ╎     ╎ │ IMP-002 │ ╎
  │  ╎   │               │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │             ┌─────────┐ ╎     ╎ ┌─────────┐ ╎
  │  ╎   └───────────▶ │ ADR-003 │ ╎ ◀── ╎ │ IMP-003 │ ╎
  │  ╎                 └─────────┘ ╎     ╎ └─────────┘ ╎
  │  ╎                             ╎     ╎   │         ╎
  │  └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘     ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   ▼         ╎
  │                      │               ╎ ┌─────────┐ ╎
  └──────────────────────┼─────────────▶ ╎ │ IMP-004 │ ╎
                         │               ╎ └─────────┘ ╎
                         │               ╎             ╎
                         │               └−−−−−−−−−−−−−┘
                         │                   │
                         │                   │
                         │                   ▼
                         │                 ┌─────────┐
                         └─────────────▶   │   end   │
                                           └─────────┘
```

I'm not totally sure how useful this would be but it's roughly equal to the obsidian local graph. it's worth a shot. However, it doesn't seem like it requires new graph primitives other than eventually adding an ascii output. 

##### graph 
Export a dependency graph around an ID.

- `[--id ABCD]: Define the ID or TITLE for the root node of the local graph to display. 
- `[--depth N] `: Set maximum number of recursive notes the graph will include. 
- `[--include-bidirectional] `: Include both dependencies as well as notes depending on the selected ID.  
- `[--format mermaid|dot|json|ascii]`: Select the output format. If undefined it prints graphviz ascii in the terminal. 

---

#### Get

```markdown 

##### get 
`--id ADR-021 [--include-dependents]` 
- Traverse a note (and it's dependencies) and print the contents. This tool is primarily designed for an AI consumer and is the primary 'RAG' in CLI-RAG. 

##### cluster 
`[--id ABCD] [--depth N] [--include-bidirectional]` 
```

Currently the user story here is a bit unclear. Cluster should probably just be a modifier e.g. 

- `get --id <ID>` (Gets the single node's content)
- `get --id <ID> --cluster [--depth N --include-bidirectional]` (Gets the content for the entire cluster/neighborhood)
- `graph --id <ID>` (Graphs the cluster, as graph implicitly operates on a cluster)

the point being the top level commands should be 'verbs' so all in;  

##### get 
Traverse a note (and it's dependencies) and print the contents. This tool is primarily designed for an AI consumer and is the primary 'RAG' in CLI-RAG. 

**Flags**
- `--id <ID>`: Define any tracked note ID 
- `[--cluster] `: Pull an ID and it's connections as defined by the following flags. 
- `[--depth N] `: Set maximum number of recursive notes the path will traverse. 
- `[--include-bidirectional]`: Include dependencies and notes depending on the selected ID.  

## Better Error Handling and Output 

```markdown 
- **Autocompletion and ID Suggestions**:
    
    - **Why?** Commands like `get --id ADR-022` are error-prone if IDs are mistyped. Your `completions` command is a start—enhance with dynamic suggestions.
    - **How**: In `get`/`cluster`/`path`, if `--id` is invalid, fuzzy-search IDs (like your `search`) and suggest: "Did you mean ADR-022? (y/n)". Use `clap` 's built-in validation for runtime checks.
- **Config Ergonomics and Defaults**:
```

```markdown 
- **Error Handling and UX**:
    
    - **Why?** Rust's `anyhow` is used well, but user-facing errors could be friendlier (e.g., "Config not found—run init?").
    - **How**: In `load_config`, if no config, prompt to run `init`. Add verbose logging with `--debug` (use `env_logger` crate). For `validate`, group errors by file/schema for easier debugging.
```

```markdown
- **Improved Output and Formatting**:
    - **Why?** Plain output is functional but can be noisy (e.g., long paths in `doctor`). JSON is great for scripting, but humans need summaries.
    - **How**: For plain mode, use tables (e.g., via `comfy_table` crate: add to Cargo.toml). In `doctor`, output like:
        
        +---------+-------+
        | Base    | Mode  |
        +---------+-------+
        | docs/   | index |
        +---------+-------+
       
	- Colorize errors/warnings in `validate` (use `anstream` for cross-platform coloring—already in your deps).
```


---

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

A more ergonomic and intuitive developer experience. see [[ADR-003b-v1-CLI-commands]]
</file>

<file path="ADR-003b-v1-CLI-commands.md">
---
id: ADR-003b
tags:
  - cli
  - refactor
status: accepted
depends_on:
  - ADR-001
  - ADR-004
created_date: 2025-08-25
last_modified: 2025-08-26
related_files:
  - ~/cli-rag/src/commands
---

# v1-CLI-commands


## Objective
<!-- A concise statement explaining the goal of this decision. -->

Present a concise "final" list of commands before full implementation. These tools are designed for either a human or an AI consumer.


## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

---

#### Init 
Create `.cli-rag.toml` in the current repo and open it in an editor by default.

**Flags** 
- `--schema <S>`: Opens a commented but blank scheme template in the primary editor. Optionally define a name| Name is required with `silent`. 
- `--silent`: Write the default template directly to disk without opening the config in the editor 
- `--force`: Overwrite `.cli-rag.toml` even if it exists
- `--print-template`: Print template to stdout

---

#### new 
The primary tool for creating a new note. Can open the defined editor with the `--edit` flag. If  
  
**Flags**
- `--schema <S>`: Select a .toml defined schema to use as a template. 
- `--title <T>`: Create a new note defined by Title. 
- `--id <I>`: Create a new note defined by ID. 
- `--edit`: Open the note in the defined editor. 
- `--agent`: Generates an agent friendly text prompt.

---

#### get 
Traverse a note (and it's dependencies) and print the contents. This tool is primarily designed for an AI consumer and is the primary 'RAG' in CLI-RAG. 

**Flags**
- `--id <ID>`: Get any tracked note by unique ID 
- `[--depth N] `: Set maximum number of recursive notes the path will traverse. 0 returns the node only. `Defaults = 2`
- `[--include-bidirectional]`: Include both dependencies as well as notes depending on the selected ID.  

---

#### watch 
Watches filepaths for changes and incrementally validates & update the indexes. Debounces rapid events; writes on success (unless `--dry-run`).

**Flags**
- `[--debounce-ms 400]`: Set custom debounce time. 
- `[--dry-run]`: Watches file changes but does not write to the index. 
- `[--full-rescan]`: Fully scans all tracked paths and updates the index. 

---

#### graph 
Export a dependency graph around an ID. Prints the local graph in the terminal. 

**Flags**
- `[--id ABCD]: Define the ID or TITLE for the root node of the local graph to display. 
- `[--depth N] `: Set maximum number of recursive notes the graph will include. 0 returns the node only. `defaults = 2`
- `[--include-bidirectional] `: Include both dependencies as well as notes depending on the selected ID.  
- `[--format mermaid|dot|json|ascii]`: Select the output format. If undefined it prints graphviz ascii in the terminal. 

An idea that keeps coming to mind is using the local graph as a navigation system navigation system for the tui/cli. The key is that [graphiz directly supports ascii output.](https://graphviz.org/docs/outputs/ascii/) This creates a possible workflow where we pull a local graph and append the ID's so it's 

1. ADR-001 
2. ADR-002 
   
You are then shown a screen like this where you can with a single key press to fly around notes. we could open them in a pager or an editor (and that could be a flag in the .toml) e.g. 
```
     ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
     ╎             adr             ╎
     ╎                             ╎
     ╎ ┌─────────┐     ┌─────────┐ ╎       ┌─────────┐
  ┌─ ╎ │ ADR-001 │ ◀── │ ADR-000 │ ╎ ◀──   │  start  │
  │  ╎ └─────────┘     └─────────┘ ╎       └─────────┘
  │  ╎   │               ▲         ╎         │
  │  ╎   │               │         ╎         │
  │  ╎   │               │         ╎         ▼
  │  ╎   │               │         ╎     ┌−−−−−−−−−−−−−┐
  │  ╎   │               │         ╎     ╎     imp     ╎
  │  ╎   ▼               │         ╎     ╎             ╎
  │  ╎ ┌─────────┐       │         ╎     ╎ ┌─────────┐ ╎
  │  ╎ │ ADR-002 │       │         ╎     ╎ │ IMP-001 │ ╎
  │  ╎ └─────────┘       │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │               │         ╎     ╎ ┌─────────┐ ╎
  │  ╎   │               │         ╎     ╎ │ IMP-002 │ ╎
  │  ╎   │               │         ╎     ╎ └─────────┘ ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   │         ╎
  │  ╎   │               │         ╎     ╎   ▼         ╎
  │  ╎   │             ┌─────────┐ ╎     ╎ ┌─────────┐ ╎
  │  ╎   └───────────▶ │ ADR-003 │ ╎ ◀── ╎ │ IMP-003 │ ╎
  │  ╎                 └─────────┘ ╎     ╎ └─────────┘ ╎
  │  ╎                             ╎     ╎   │         ╎
  │  └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘     ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   │         ╎
  │                      │               ╎   ▼         ╎
  │                      │               ╎ ┌─────────┐ ╎
  └──────────────────────┼─────────────▶ ╎ │ IMP-004 │ ╎
                         │               ╎ └─────────┘ ╎
                         │               ╎             ╎
                         │               └−−−−−−−−−−−−−┘
                         │                   │
                         │                   │
                         │                   ▼
                         │                 ┌─────────┐
                         └─────────────▶   │   end   │
                                           └─────────┘
```

---

#### doctor 
Show resolved config, filepaths, discovery mode (index vs scan), and quick stats. Reports per-type counts when schemas are defined, and unknown-frontmatter stats.

```markdown
- **Improved Output and Formatting**:
    - **Why?** Plain output is functional but can be noisy (e.g., long paths in `doctor`). JSON is great for scripting, but humans need summaries.
    - **How**: For plain mode, use tables (e.g., via `comfy_table` crate: add to Cargo.toml). In `doctor`, output like:
        
        +---------+-------+
        | Base    | Mode  |
        +---------+-------+
        | docs/   | index |
        +---------+-------+
        
	- Colorize errors/warnings in `validate` useing `anstream` for cross-platform coloring
```

---

#### search --query `<substr>`
Fuzzy search by ID/title across tracked notes.

**Flags**
- `--schema <S>`: Search in only a single defined schema 
- `--recent <X>`: Lists the last `X` changes tracked on the index

---

#### path --from ABC --to XYZ 
Returns the shortest dependency path between two notes or throws and error if none exist.
  
**Flags**
- `[--max-depth N]`: Set maximum number of recursive notes the path will traverse. 

output should show graph edges 
```bash 
ADR-024 → IMP-006 (depends_on)                  # explicit frontmatter
IMP-006 → ADR-029 (mentions: [[ADR-029]] in body, L42)
```

---

#### groups
lists tracked notes organized by `groups` frontmatter. If the frontmatter is not active this will throw errors. 

**Flags**
- `--list`: print all semantic groups tracked by `validated_frontmatter` on the current graph.

---

#### validate 
Lint's notes based on the various `[[schema]]` configured in `.cli-rag.toml`. By default all index scans are incremental reparse's using `mtime` and `size`. Exits with an error code in the event validation fails. Writes out `index_relative` unless `--dry-run` is used.
  
**Flags** 
- `--dry-run`: Validate the index and print errors without writing or updating the index on disk. Prints errors or success. 
- `--full-rescan`: Scans all files regardless of tracked `mtime` or `size`
- `--write-groups`: Write out only `groups_relative` and updates `semantic-groups.json`. This requires an active schema with `validated_frontmatter` and `groups` active.  
- `--write-all`: Write out both `groups_relative` and `index_relative`. 

---

### Ideas...

#### Help 
Prints on stdout 

**Flags**

---

#### list

we need some kind of command to list out "all in progress, all closed, all draft." this implies this logic needs to be baked in deeper for basic agile states. this need probably should be part of search or a graph action etc it takes a deeper rethink of the verb space now that i have a clearer idea what actions are needed. 


---


## The Missing Tools 

**The "Refactor" Problem:** A common pain point in these systems is renaming a note. If NPC-Grak.md is renamed to NPC-Grak-The-Loud.md, how do all the `[[NPC-Grak]]` links get updated? A `cli-rag refactor --id <ID> --new-title <T>` command would be a massive power feature.

In the same vein we could have an add dependency or supersede tool. the issue is keeping the abstractions universal. 


## Decision
<!-- What is the change that we're proposing and/or doing? -->

Accept the above and refactor impacted files. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

Increased CLI ergonomics and clarity.
</file>

<file path="ADR-003c-v1.1-CLI-commands (needs edit).md">
---
id: ADR-003c
tags:
  - cli
  - refactor
status: accepted
depends_on:
  - ADR-001
  - ADR-004
created_date: 2025-08-25
last_modified: 2025-08-26
related_files:
  - ~/cli-rag/src/commands
---

# v1.1-CLI-commands


## Objective
<!-- A concise statement explaining the goal of this decision. -->

Present a concise "final" list of commands before full implementation. These tools are designed for either a human or an AI consumer.

## Ideation 


- There should probably/maybe be a top level GTD command? 
	- update kanban 
	- update due date 
	- etc 

There is a chance this is a more generic "update note" tool but it's not ultra obvious how you'd actually structure that feedback loop for an agent on some items. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

---


- **Every command supports `--json`** for machine use; human pretty by default.  
- **Idempotent reads, explicit writes.** Anything that mutates disk says so.
- **Same nouns across CLI + NVIM** (note, schema, graph, index).
- **Lua is policy, not parsing** Lua hooks run only in `new`/`validate`.

---

### Commands

## `init`

Create `.cli-rag.toml` (and optional `templates/`), and open the commented file in the default editor.

**Flags**

- `--schema <NAME>` scaffold a commented `[[schema]]` block (writes to `.cli-rag.toml` or `templates/<NAME>.toml` if `--separate`).
- `--separate` put schema into `.cli-rag/templates/<NAME>.toml` instead of inline.
- `--silent` write without opening editor.
- `--force` overwrite if exists.
- `--print-template` print to stdout (no files).
- `--json` machine summary of what was created.

## `new`

Create a new note (runs Lua hooks for id/frontmatter/template fill). Optionally open in editor. **Human-oriented.**

**Flags**

* `--schema <NAME>` define schema under which the note will be created
* `--title <T>` and/or `--id <I>` (if both, engine verifies consistency with schema rules)
* `--edit` open the created note in the configured editor
* `--dry-run` print would-be filename/frontmatter/body (no write)
* `--print-body` when used with `--dry-run`, include the body text
* `--json` return `{path, id, schema, frontmatter}` (body omitted unless `--print-body`)

## `get` (alias show)

Resolve a note and (optionally) its neighborhood; print for humans or ai.

**Flags**

- `--id <ID>` (or `--path <P>`)
- `--depth N` (default 2)
- `--include-bidirectional`
- `--format md|ai|json`
    - `md`: stitched doc with frontmatter + appended neighbors
    - `ai`: compact JSON with `{frontmatter, text, neighbors: [...]}` optimized for LLM
    - `json`: full parse summary `{frontmatter, headings, wikilinks, md_links, code_fences, text}`

## `validate`

Run validators (TOML + Lua) and exit non-zero on any error.

**Flags**
- `--dry-run` don’t touch indexes
- `--full-rescan`
- `--write-index` write index only
- `--write-groups` write groups only
- `--write-all` both
- `--json` emits `{path, diagnostics:[{severity,code,msg,span,field}]}`
  
## `watch`

Incrementally indexes & validates while files change. Runs when the NVIM extension is open for live updating file changes. 

**Flags**
- `--debounce-ms <n>` default 400
- `--dry-run`
- `--full-rescan`
- `--json` stream structured events per change: `{"event":"validated","path":...,"diagnostics":[...]}`

## `graph`

Emit a local dependency graph for an ID (or whole repo with `--root none`).

**Flags**
- `--id <ID>|--root none`
- `--depth N|max`, `--include-bidirectional`  
- `--graph-format ascii|mermaid|dot` (default `ascii`)
- `--json` machine summary

## `status`

Show resolved config, discovery mode, counts, and unknown-frontmatter stats.

**Flags**
- `--json` machine summary
- `--verbose` include per-schema file lists
- **Human mode**: use table output; color diagnostics

## `search`

Fuzzy search ID/title; filter by schema or status.

**Flags**

- `--query <substr>`
- `--schema <S>` Search within a schema 
- `--kanban <user-defined-strings>` Search Kanban. List all tracked items with no scoping input. 
- `--TODO` Search TODO's. Lists by priority without input. 
- `--recent <X>` last X changes
- `--field` filter search by frontmatter content 
- `--json`    

## `path`

Shortest path between two IDs with edge kinds.

**Flags**
- `--from <ID>` `--to <ID>`
- `--max-depth N`
- `--json` includes `edges: [{from,to,kind,meta}]`


**Human example**

ADR-024 → IMP-006 (depends_on)
IMP-006 → ADR-029 (mentions: [[ADR-029]] L42)

## `groups`

List notes by `groups` frontmatter (if enabled in schema).

**Flags**
- `--list` list group names
- `--name <G>` show members of a group
- `--json`

## `ai` (JSON/NDJSON outputs)

Agent workflow for two-phase creation with on-creation validation. Not intended for direct human use.

### `ai draft start`

Begin an agent draft; reserves ID/filename and returns the section/LOC contract.

**Flags**
- `--schema <NAME>`
- `--title <T>` (optional if `--id` provided)
- `--id <I>` (optional; engine may still assign)
- `--json` (default)

---

### `ai draft submit`

Finalize a draft by submitting filled content **before** any file is written. Enforces `scan_policy = "on_creation"` (LOC per heading, heading rules, frontmatter enums/regex, Lua `validate`).

**Flags**
- `--draft <DRAFT_ID>` (required)
- one of:
    - `--stdin` (reads structured JSON `{frontmatter, sections}` from stdin)
    - `--sections @path.json` (same shape as stdin)
    - `--from-file <path.md>` (engine parses headings/sections)
- `--allow-oversize` write even if LOC caps fail; marks `needs_attention=true`
- `--json` (default)
    

---

### `ai draft cancel`

Abort and remove a pending draft; releases reserved ID/filename.

**Flags**

- `--draft <DRAFT_ID>`
- `--json` (default)

---

### `ai draft list`

List active/stale drafts in the draft store.

**Flags**

- `--stale-days <N>` filter to drafts older than N days (default: show all)
- `--json` (default)

---

**Exit codes (ai subcommands)**

- `0` success
- `2` validation failed (diagnostics returned)
- `3` draft not found/expired
- `4` schema/config error
- `5` IO/index lock error

---

### Cross-cutting flags (all verbs)

- `--json` machine output everywhere.
- `--color auto|always|never`
- `--cwd <path>` override working dir (great for NVIM/project roots).
- `--editor <cmd>` and `--no-editor`.

## Notes 

### `init`

#### Notes 

The first run of init should maybe be very very lightly interactive e.g.

Init opens

```bash
Welcome to cli-rag! Do you want to: 
    1. Dive into a custom config [**RECOMMENDED]**
    2. Set the Project_Manager preset? 
    3. Set the RPG_Manager preset?
    4. Set the Personal_Notes preset?  
```

The new user burden is very high, currently we ship an application that does nothing on install. The alternative is to just say "no this is a project manager tool first and foremost" which is arguably the most honest. 

the preset screen would need basic information eg 

```bash
Project Manager:
  - ADR schema for architectural decisions
  - IMP schema for implementation tickets  
  - Kanban workflow with due dates
  - Git-friendly incremental IDs
  
[Press ENTER to use this preset, or ESC to go back]
```

presets should actually live in the binary directly as a const string. 

---

### AI 

#### Behaviors & contracts

##### `ai draft start`

- Reserves ID/filename (no file written).
- Runs Lua `id_generator` + `render_frontmatter`.
- Returns a **contract** the agent must satisfy:
    

```json
{
  "draft_id": "dft_7fb0c2",
  "schema": "ADR",
  "filename": "ADR-003-circuit-breaker.md",
  "constraints": {
    "headings": [
      {"name":"Objective","max_lines":50},
      {"name":"Context","max_lines":200},
      {"name":"Decision","max_lines":50},
      {"name":"Consequences","max_lines":50},
      {"name":"Updates","max_lines":100}
    ],
    "heading_strictness": "missing_only",
    "frontmatter": {
      "allowed": ["id","status","tags","created_date"],
      "readonly": ["id","created_date"],
      "enums": {"status":["draft","proposed","accepted","superseded","cancelled"]}
    }
  },
  "seed_frontmatter": {"id":"ADR-003","status":"draft","created_date":"2025-08-30","tags":[]},
  "ttl_seconds": 86400,
  "content_hash": "sha256:…"
}
```

Persist a small draft file: `.cli-rag/drafts/dft_7fb0c2.json`.

##### `ai draft submit`

- Accepts either:
    
    - **structured JSON** on stdin:
        ```json
        {"frontmatter":{"tags":["resilience"]},
         "sections":{"Objective":"…","Context":"…","Decision":"…","Consequences":"…","Updates":""}}
        ```
    - `--sections @file.json` with the same shape
    - `--from-file note.md` (engine parses headings/sections)
        
- Engine builds the note **in memory**, then:
    
    1. Parse frontmatter/body
    2. Enforce `heading_strictness` & **per-heading LOC**
    3. Validate frontmatter (regex/enums)
    4. Run Lua `validate`
        
- If `scan_policy="on_creation"` and any **error** → **no write**:
    
    ```json
    {"ok":false,"draft_id":"dft_7fb0c2",
     "diagnostics":[
       {"severity":"error","code":"LOC_Objective","heading":"Objective","max":50,"actual":73},
       {"severity":"warning","code":"LINK_MIN","msg":"Add at least 1 wikilink"}
     ]}
    ```
    
- If OK → write file, clear draft, return:
    
    ```json
    {"ok":true,"path":"notes/ADR-003-circuit-breaker.md","id":"ADR-003","schema":"ADR"}
    ```
    

###### Notes

- `--allow-oversize` lets you create despite LOC errors; engine marks `needs_attention=true` in index so `validate` still fails later.
- Include `content_hash` in `submit` to make retries idempotent:
    - Engine rejects if same draft already finalized with same hash.

##### `ai draft cancel`

- Deletes the draft file; releases reserved ID/filename.

##### `ai draft list`

- Emits JSON array of stale/orphaned drafts with `created_at`, `schema`, `filename`. Use `--stale-days` to filter.

---

### Stable JSON schemas (so NVIM is trivial)

**`get --format ai`**

```json
{
  "id": "ADR-002",
  "schema": "ADR",
  "frontmatter": { "status": "draft", "tags": ["TUI","NeoVIM","rataTUI"] },
  "text": "…",
  "neighbors": [
    {"id": "ADR-001", "edge": "depends_on"},
    {"id": "ADR-003", "edge": "depends_on"}
  ]
}
```

**`validate --json` event (also from `watch`)**

```json
{"event":"validated","path":"notes/ADR-002-Visual-Mode-planning.md","ok":false,
 "diagnostics":[{"severity":"warning","code":"LINK_MIN","msg":"Add a wikilink","span":[123,145]}]}
```

---


## The Missing Tools 

**The "Refactor" Problem:** A common pain point in these systems is renaming a note. If NPC-Grak.md is renamed to NPC-Grak-The-Loud.md, how do all the `[[NPC-Grak]]` links get updated? A `cli-rag refactor --id <ID> --new-title <T>` command would be a massive power feature.

In the same vein we could have an add dependency or supersede tool. the issue is keeping the abstractions universal. 


## Decision
<!-- What is the change that we're proposing and/or doing? -->

Accept the above and refactor impacted files. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

Increased CLI ergonomics and clarity.
</file>

<file path="ADR-004-toml-config-versioning.md">
---
id: ADR-4
tags:
  - toml
  - config
  - versioning
  - future_proof
status: draft
depends_on: [ADR-001]
created_date: 2025-08-25
last_modified: 2025-08-25
related_files: [.cli-rag.toml]
---

# toml-config-versioning

## Objective
<!-- A concise statement explaining the goal of this decision. -->

As we change schema processing we need a way to support and deprecate older config versions. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

reasonable statement of the issue 

```gemini 2.5 pro  
- **You are developing cli-rag v0.3.** In this version, you decide to make a breaking change. You rename the legal_entry key to allowed_values because it's clearer.
    
- **In your Rust code, you make the following changes:**
    
    - The parser for config_version = "0.3" now only accepts allowed_values.
        
    - The parser for config_version = "0.1" and "0.2" is still there, but you add a compile-time warning to it:
        
        code Rust
        - - IGNORE_WHEN_COPYING_START
        
        IGNORE_WHEN_COPYING_END
        
            `#[deprecated(since = "0.3.0", note = "v0.1 support will be removed in v0.4.0. Please upgrade your config.")] fn parse_v01_config(...) { ... }`
          
        
- **A user has a project configured with config_version = "0.1".**
    
    - They upgrade their cli-rag binary to 0.3.
        
    - When they run any command (validate, get, etc.), the tool reads their config_version = "0.1".
        
    - The tool works perfectly, but it prints a clear, non-blocking warning to the console: "Warning: Your configuration is using a deprecated format (v0.1). This format will be removed in a future release (v0.4). Please consider upgrading."
        
- **The user decides to upgrade.**
    
    - You can provide a simple cli-rag config upgrade command that reads their v0.1 file, renames the keys, and writes out a new file with config_version = "0.3".
```

Simple model of you can add features but breaking changes are a new api version. 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Implement a config versioning flag 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

we can change the application and not break user notes. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-005-MCP-server-wrapper.md">
---
id: ADR-005
tags:
  - MCP
  - LLM
  - Agentic
  - Tooling
status: accepted
depends_on: ADR-001, ADR-002, ADR-003b
created_date: 2025-08-26
last_modified: 2025-08-26
related_files: []
---

# MCP-server-wrapper

## Objective
<!-- A concise statement explaining the goal of this decision. -->

Translate the tools to an MCP to allow an LLM to be the 'head' of our headless knowlege graph so both the user and LLM can contribute to schema constrained notes. This should be an "even better" situation, the agent should be able to theoretically work via cli or MCP. 

Ultimately the CLI is the more universal tool to nearly all deployments. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

LLM's when prompted to document a section of a conversation produce long unstructured brain dumps often in one off ad hoc directories. 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

No development will occur until the CLI tools are completely locked. This should serve largely as a 'thin wrapper' over the existing tooling leaning on the fact all tools produce an ndjson output. 

This will be a standalone server unconnected to my local dev tooling. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

A clear separation between human and llm control surfaces so neither requires compromising the other. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-006-config-loader-error-codes.md">
---
id: ADR-006
tags:
  - toml
  - config
  - merge_conflict
status: accepted
depends_on: ADR-001, ADR-004
created_date: 2025-08-27
last_modified: 2025-08-27
related_files:
  - .cli-rag.toml
---

# config-loader-error-codes

## Objective
<!-- A concise statement explaining the goal of this decision. -->

We do not wish to allow complex merge conflicts and inheritance across the .toml config files. 

We accept the following invariants: 

1. **Exactly one** top-level `.cli-rag.toml` is permitted. All files below this in the tree inherit this config. 
2.  All `[[schema]]` names are **unique**.
3. Imported files are allowed to define **schemas only** (no `[scan]`, `[graph]`, `[retrieval]`, `[authoring]`, etc.). If they do, it’s an error.

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

**Process**
1. Read the single project .cli-rag.toml.
2. Read any import = [...] files.
3. Validate each import contains only `[[schema]]` blocks (else: error).
4. Concatenate all schemas (project + imports).
5. Enforce unique schema names (else: error).
6. Freeze the effective config.

**Example Errors**
- E100: Multiple project configs detected. Only one .cli-rag.toml is allowed.
- E110: Illegal top-level key [scan] in import templates/ADR.toml. Imports may define schemas only.
- E120: Duplicate schema name "ADR" (defined in templates/ADR.toml and templates/ADR-pack.toml).
  
## Decision
<!-- What is the change that we're proposing and/or doing? -->

adopt a strict 1 top level config + all scheme tables must be named uniquely rule. if else, error. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

Eliminate a class of bugs and creeping config complexity wholesale. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-007-general-error-codes-ideation.md">
---
id: ADR-007
tags:
  - errors
  - error_codes
status: draft
depends_on: ADR-001, AD-003b
created_date: 2025-08-27
last_modified: 2025-08-27
related_files: []
---

# general-error-codes

## Objective
<!-- A concise statement explaining the goal of this decision. -->

A parking lot for error code ideas as they come up in llm chats or otherwise 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

```
1. **File matches multiple schemas**

   * e.g., `docs/ADR-024.md` matches both `["ADR-*.md"]` and `["**/*.md"]`.
   * **Policy:** default = **error** (simple & safe). Optional future knob: `schema.priority` (higher wins).
   * Error: `E200: File docs/ADR-024.md matched multiple schemas: ADR, CatchAll. Disambiguate or set priority.`

2. **Duplicate IDs across files** (when `identity_source = frontmatter`)

   * Two notes both claim `id: ADR-024`.
   * **Policy:** **error** (authoritative ID must be unique).
   * Error: `E210: Duplicate id ADR-024 in docs/ADR-024.md and notes/ADR-024.md.`

3. **Missing/invalid ID for ID-managed schemas**

   * **Policy:** **error** if schema requires `id`; otherwise warn/skip.
   * Error: `E220: Missing required frontmatter key 'id' for schema ADR in docs/ADR-XXX.md.`

4. **Unresolved references** (`depends_on` points to unknown id)

   * **Policy:** choose severity per schema (`error|warning`).
   * Error: `E230: depends_on → ADR-999 not found (referenced by ADR-024).`

5. **Multiple schemas apply to the same note type accidentally** (design-time)

   * This is really a variant of #1; your strict error covers it.

6. **Cycles in the graph** (if disallowed)

   * **Policy:** usually warn, optionally error if schema says DAG only.
   * Error: `E240: Cycle detected ADR-001 → ADR-007 → ADR-001 (schema ADR requires DAG).`

7. **File outside declared scan roots**

   * **Policy:** warn or ignore, your call.
   * Error: `E250: File notes/ADR-024.md is outside [scan.filepaths].`
```

```
### 3. Template Variable Conflicts

What happens if someone names a frontmatter field "title" or "id"? You might need a precedence rule or namespace separation.
## Missing Pieces

1. **Conflict Resolution**: If multiple schemas match the same file pattern, which wins?
```

error on conflict, explain the merge error in stderr

by the opposite hand successes should just be silent unless we have a very good reason. fire writes "this will update x notes (list) y/n " is probably sane when we add file operations. 



```
## Template Variable Collision Still Unaddressed

Your AI-MEM template uses `{{title}}` but what if the AI sets a frontmatter field called "title"? You need explicit precedence:

```toml
[schema.new.template]
variable_precedence = ["system", "frontmatter", "computed"]
```

worth thinking through if a conflict is just an error. less overhead on the user frankly to just get "change x" vs setting inheritance logic. 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Accept the above at least in principal and work to expand the list. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

A more predictable and informative cli. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-008-ai-rag.toml.md">
---
id: ADR-008
tags:
  - AI
  - LLM
  - RAG
  - agentic
  - automation
status: draft
depends_on:
  - ADR-001
created_date: 2025-08-27
last_modified: 2025-08-27
related_files: []
---

# ADR-008-ai-mem.toml

## Objective
<!-- A concise statement explaining the goal of this decision. -->

This tool is designed to serve as a RAG for an AI. The most extreme version of this idea is "what if we make the AI itself write out to a zettelkasten, that it can search, and it's schema's force it to interlink"

This is a somewhat experimental idea to dogfood. In general this should not at first require any new code. This note is a tracker for findings, needs and additional requirements as we find if this idea is workable. 

The some what unclear space is if we should use our own logic for document linking or lean on something like markdown oxide as an LSP. It may make sense to keep our most core graph edges fully locally processed. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

`have ai genrerate it's own dogfood here when the time is right`

stuff like so 
```toml
template = """
# Instructions
1. Extract the NPC name from the user's request
2. Identify 2-3 existing notes that would logically connect
3. Generate a confidence_score based on:
   - Explicit user details: 0.8-1.0
   - Inferred from context: 0.5-0.7
   - Speculative additions: 0.2-0.4
"""
```

### Possible Future Requirements (scratchpad) 

Nothing thought trough this is just a place to store conversation snips

```gemini 2.5 pro
**1. A More Powerful Query Language:**
*   **The Need:** The simple `search --query <substr>` will not be enough. The AI will need to ask much more sophisticated questions of its own memory, such as:
    *   "Find all memories with `confidence_score > 0.8` that are connected to `ADR-005`."
    *   "Find all memories created in the last 24 hours with the keyword `database`."
*   **The Implication:** This breathes new life into the deferred `ADR-DRAFT-simple-query-dsl`. A rich, metadata-aware query engine will become a core requirement.

**2. Specialized Agentic Commands:**
*   **The Need:** While a wrapper script can orchestrate the AI, you will eventually want to build first-class commands to support this workflow.
*   **The Implication:** This could lead to a new suite of commands like:
    *   `cli-rag ai create-memory --prompt "Summarize this..."`: A command that takes a prompt, gets the structured JSON from the LLM, and uses the `note_template` to write the file.
    *   `cli-rag ai find-related --id AIM-123e45... --depth 2`: A specialized retrieval command optimized for the AI's own graph.

**3. Advanced Graph Analysis:**
*   **The Need:** Once the AI has created thousands of notes, the human user will need tools to understand the structure of the AI's "mind."
*   **The Implication:** `doctor` and `graph` will need to evolve. You might add flags like:
    *   `doctor --find-orphan-ai-notes`: Find AI memories that have no incoming links from human notes.
    *   `graph --source-of ADR-005`: Generate a graph of all AI memories that were derived from a specific human-written ADR.
```

complaints from opus but i'm somewhat less concerned given the vibe is a bit more "experiment" but for best results this is all likely true. I just want to try the other way for fun. 

```
## The Deeper Issue: Bidirectional Trust

If the AI can write notes that influence its own future retrievals, you're creating a feedback loop. You need:

1. **Immutable human notes**: AI shouldn't edit human-authored content
2. **Trust scoring**: Weight human notes higher in retrieval
3. **Audit trail**: Track which agent (human/AI) created/modified each note

This might look like:


[schema.authorship]
immutable_after_creation = true  # For human schemas
author_type = "human"  # or "ai"
trust_weight = 1.0  # Human notes weighted higher in search
```

```fair
### 2. Circular Dependency Detection

With `depends_on` validation, you'll need cycle detection in your graph traversal. The config doesn't specify how to handle this.

## Critical Design Gap: Memory Lifecycle

If the AI creates thousands of AIM-* notes, you need lifecycle management:

1. **Decay/Archival**: Old memories with low confidence scores that haven't been accessed should fade
2. **Consolidation**: Multiple related memories should potentially merge
3. **Versioning**: When the AI updates its understanding, does it edit or create new notes?

Consider adding:


[schema.lifecycle]
archive_after_days = 90
min_confidence_to_persist = 0.3
consolidation_strategy = "merge_similar"
```

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Develop a set of best practices and ship with the note as the core example note in the config file. 


## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

Change in mental approach post implementation impacts will be observed and determined. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-009-GTD-ideation.md">
---
id: ADR-009
tags:
  - CLI
  - org-agenda
  - todo
  - tasklist
  - GTD
  - NeoVIM
status: pending
depends_on: 
  - ADR-002
  - ADR-001
  - ADR-004
  - ADR-008
  - ADR-010
  - ADR-AI-001
created_date: 2025-08-25
last_modified: 2025-08-25
related_files: [.cli-rag.toml]
---

# GTD-ideation

## Objective
<!-- A concise statement explaining the goal of this decision. -->

Goal: The main TUI screen shows a agenda somehow created across notes in front matter maybe even a simple "due now" or a data entry flag 

This could be structured as a `managed_frontmatter` with a check against a due date field maybe?. It's logical but I don't honestly work that way. I more would want to be able to flag things in notes and somehow have that create a todolist with priority buckets. 

Creating an interactive kanban in the TUI that edits the front matter as you make changes could in theory is possible. write changes to the index and then flush out to the file on exiting the Major Mode/TUI.  

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

### **CRITICAL!: See [[ADR-AI-002-gtd-kanban-integration]] for full context.** 

Straightforward project tool that allows setting a tracked priority field. This should be functionally a validator on a schema that allows you to track any tag for date/etc and add it to GTD. 

Where this could shift is the question "what if the AI could set it's own org agenda?"

> `cli-rag --ToDO`
> 
> 1. TASK-005
> > - one line context note    
> 2. TASK-002
> > - one line context note    
> 3. TASK-001
> - one line context note    

Something like this is the path where it becomes a more key feature. 

Might work something like this eg

**1. The Trigger: `gtd` in `managed_frontmatter`**

Defines for cli-rag that it should monitor gtd: for true/false 

```toml
# In an "ADR" schema
[schema.frontmatter]
    custom_frontmatter = ["id", "title", "status"]
    # By placing 'gtd' here, we declare it as a key with special logic.
    # The system will now look for a corresponding [schema.gtd] block.
    managed_frontmatter = ["depends_on", "gtd"]
```

**2. The Configuration Block: `[schema.gtd]`**

Because `gtd` is a `managed_frontmatter` key the following rules are applied to any note flagged `true`

```toml
# =============================================================================
#                        # --- GTD VALIDATED BEHAVIOR --- #
# =============================================================================
# This block is active because 'gtd' is in the validated_frontmatter list.
# It defines the logic for the 'gtd' key itself and the behavior it enables.
[schema.gtd]
    # This check applies to the 'gtd' key itself.
    # It ensures the key's value is valid for activating/deactivating the task status.
    # So, GTD: "maybe" would be an error.
    legal_entry = [true, false, "[ ]", "[x]"]
    severity = "error"
    
    # This flag tells the system that if the 'gtd' key evaluates to true,
    # then this note should be added to the dedicated GTD index.
    index_on_activate = true

    # These are the additional frontmatter fields that become REQUIRED
    # only when the 'gtd' key is present and evaluates to an active state.
    required_fields_on_activate = ["priority", "status"]

    # Default values to inject when a note is promoted or created as a task.
    [schema.gtd.default_values]
        status = "pending"
        priority = 50
        assignee = "unassigned"

    # Specific checks for the GTD-related fields. These ONLY run
    # if the 'gtd' key is present and active.
    [[schema.gtd.check]]
        type = "frontmatter_fields"
        severity = "error"
        [schema.gtd.check.fields]
            [schema.gtd.check.fields.status]
                legal_entry = ["pending", "active", "blocked", "completed", "deferred"]
            [schema.gtd.check.fields.priority]
                legal_entry = "integer"
                range = [0, 100]
```

then the operation of GTD tracking itself is written to something like json,toml,yaml the idea being the AI managing it's rag can overwrite the priority list directly + tracking additional special logic. we'll see.  

### From a conversation with an llm
```bash
 > I think we probably need to think in terms of like deadlines and targets take a look over 'ADR-002-Visual-Mode-planning' the idea is kind of in the neovim main screen you see a sort of magit/org agenda screen. these are my deliverables and these are my current notes grouped by schema in foldable lists so i see my imp-* tickets my adr-* planning but also whats upcoming eg 
  

V ToDo ! 
  - 8-16 - DueNow!: [[imp-001-*]]
  - Tagged!: [[ADR-010-the-LUA-escape-hatch]]: -[] implement the above steps before proceed on implementing the embedded lua runtime

V **Kanban**
	> Backlog
	V In-Progress
	  L IMP-004
	  L IMP-002 
	> Completed
	> Cancelled 

v **Templates** 
	1 - IMP-*  
	2 - ADR-*
	3 - ADR-DB-*
		
v **ADR** 
	- ADR-001-my-first-plan
	- ADR-002-my-happy-place
> **ADR-DB** 
v **IMP** 
	+ IMP-001-database-spike
	+ IMP-002-websocket-spike  
       
TAB: Collapse/Expand | RETURN: Select | SPACE+F: FuzzyFind | G: GraphView


So probably parsing for some kind of syntax both in the header for kanban status + duedate. But then the real ideal also maybe is parsing for a phrase like 

{TODO}: -[] implement the above steps before proceed on implementing the embedded lua runtime
 
Then anything on that line gets added to the TODO screen. if the -[x] is filled out its removed. 

Ideally we lean on the lsp to do those updates and edits maybe. 
``` 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Most likely defer for v1 and when TUI planning picks consider doing a basic due date version and then start working the implement write features so a checkbox can mark an item done etc little interlinking. it's got to be a slow process and it will be tied to a yet undecided ui. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

~~No direct impact on the core function but a baseline for extending the tool as it gains a gui. It's a polish and not core to 1.0.~~ 

I've come to see this effort as more core to the goal. We will aim to add for v1 but if it hits blockers it's not 100% required. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-010-the-LUA-escape-hatch.md">
---
id: ADR-010
tags:
  - LUA
  - config
  - configuration
  - template
  - validators
status: draft
depends_on: 
  - ADR-001
  - ADR-002
  - ADR-009
created_date: 2025-08-28
last_modified: 2025-08-28
related_files: [.cli-rag.toml]
---

# the-LUA-escape-hatch

## Objective
<!-- A concise statement explaining the goal of this decision. -->

The .toml has become increasingly complex as it's been iterated on in planning. Some of these features are not practical to support and the ability to grow is limited. A hard locked feature set also creates a natural v2 pressure. 

Instead we will implement a 'LUA Escape Hatch'. This will be possible in the `generation` and `validation` sections of the .toml `[[schema]]` letting custom logic be defined to validate against almost all aspects of the note.  

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

### Core Responsibility Split

- **Rust engine (+ winnow + Markdown parser):** parse once, build fast summaries (front-matter, headings, links, custom tokens, spans).
- **Lua hooks:** generate/validate by _querying those summaries_ and returning results. No disk, no net, no clock (unless you pass a deterministic one).

### Lifecycle 

1. **discover → load → parse**
    - Engine extracts:
        - `frontmatter`: YAML → map
        - `markdown`: headings, code fences, md links
        - `custom`: wikilinks, `{{filters}}`, `{{LOC|N}}`, etc. (via winnow/markdownoxide)
   
2. **generate (optional)**
    - `hooks.generate(ctx, api) -> { frontmatter?, body? }`

3. **validate**
    - `hooks.validate(note, api) -> { diagnostics[] }`

4. **persist/index**
    - Engine writes files, updates graph, caches. Lua never touches IO.
      
### Potential API Scope 

```gpt-5
## Read-only “data surfaces”

Minimal, predictable tables—not the whole AST.

- `ctx.schema` — `"ADR"` / `"NPC"` …
- `ctx.template` — the note template string (for generate).
- `note.frontmatter` — table (read-only snapshot).   
- `note.text` — full body text (string)
- `api.headings(level?) -> { {level, text, span} }`
- `api.links(kind?, options) -> { {kind="md|wikilink|image", target, title?, span} }`
- `api.code_fences(lang?) -> { {lang, info, text, span} }`
- `api.tokens(kind) -> { {kind, value, span} }`
    - e.g., `kind="loc_marker"` for `{{LOC|N}}`
    - e.g., `kind="filter"` for `{{title|kebab}}`
    - e.g., `kind="wikilink"` for `[[ADR-001#Section|alias]]`

- `api.graph(note_id, opts) -> { nodes[], edges[] }` (read-only: outgoing/incoming, depth)    
- `api.exists(id) -> bool`
- `api.resolve(id) -> { path, schema }?`

> **Spans** are `{start, stop}` byte offsets in `note.text`; they let Lua point at exact regions without rewriting the buffer itself.

## Safe “action surfaces”

Lua returns intentions; the engine applies them.
- **Generation**
    - `hooks.id_generator(ctx) -> "003"` (optional)
    - `hooks.filename(ctx) -> "ADR-003-circuit-breaker.md"` (optional override)        
    - `hooks.render_frontmatter(ctx) -> table` (merged by engine) 
    - `hooks.generate(ctx, api) -> { body?, frontmatter? }`

- **Validation**    
    - `hooks.validate(note, api) -> { {severity, message, code?, span?, field?}… }`

- **Edits (optional)**    
    - `api.suggest({ {span, replacement}… })` → engine applies, preserving formatting
    - or keep validation-only (simpler/deterministic)

## Determinism & sandbox
- No `io.*`, no `os.execute`. Provide:
    - `api.now()` that returns an engine-supplied ISO string (fixed/seeded in tests)
    - `api.rand()` seeded by engine per run (for stable IDs if needed)
    - `ctx.store:get/set` small KV for counters (persisted by engine)
```

### API design Intent

```gpt-5
- **Summaries, not ASTs.** Headings/links/fences/tokens cover 95% of policies; AST streaming into Lua is slow and leaky.
- **Spans everywhere.** They let Lua point at text without owning buffers.
- **Pure hooks.** Hooks receive inputs and produce outputs; engine performs side effects.
- **Stable shapes.** All API returns are plain tables with the same fields in every release.
- **Feature toggles live in TOML.** Which hooks fire, which custom tokens you recognize, and schema discovery all stay declarative.
```

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Proceed with implementing the limited escape hatch. Do not foreclose the chance we should just allow an init.lua file to bypass toml and just call the library directly. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

**Positive** 
1. We will be able to maintain a smaller, more logical core of statements for the .toml configuration dsl.
2. Users will be able to modify to meet their needs without feature requests. 
3. Users of the neovim plugin will be able to use a langauge they already know. 

**Mixed** 
1. We have to create and maintain a simple API. Ideally we expose this with an OpenAPI contract as documentation. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-011-text-parsing-stack.md">
---
id: ADR-011
tags:
  - winnow
  - parsers
  - templates
  - markdown 
status: draft
depends_on: 
  - ADR-001
  - ADR-010
  - ADR-009
created_date: 2025-08-28
last_modified: 2025-08-28
related_files: [.cli-rag.toml]
---

# ADR-010-text-parsing

## Objective
<!-- A concise statement explaining the goal of this decision. -->

Tera has many many features we don't need. To keep the implementation simple we will lean on a few custom rules [using the winnow crate. 
](https://docs.rs/winnow/latest/winnow/index.html)

We do not plan to reinvent the wheel and will lean on a mature markdown parser for non-custom logic. The main options are markdown-rs and pulldown-cmark. 

At this time the most likely pattern is producing an AST with markdown-rs and then leaning on markdown-oxide for majority of edge functions. things like `depends on` still need custom logic. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

### Issue 
Our template manager presents various items to parse. 

```
		#:                       # --- TEMPLATE VARIABLES --- #          
		#: +-----------------+---------------------------------------------------------+ 
		#: | {{id}}          | Inject the `id` field as defined by `id_generator`.     |
		#: |                 | Errors if not present.                                  | 
		#: +-----------------+---------------------------------------------------------+ 
		#: | {{title}}       | Inject the title provided via the `--title <T>` flag    |
		#: |                 | on the `new` command.                                   | 
		#: +-----------------+---------------------------------------------------------+ 
		#: | {{filename}}    | Inject the predefined filename string in full.          |
		#: +-----------------+---------------------------------------------------------+ 
		#: | ((frontmatter)) | Inject items within the `schema.frontmatter` table into |
		#: |                 | the template                                            | 
		#: +-----------------+---------------------------------------------------------+ 
		#: | {{LOC|100}}     | Set the maximum number of lines per heading.            |
		#: |                 | Only applies to LLM outputs.                            | 
		#: +-----------------+---------------------------------------------------------+ 
		#: | {{date}}        | Today's date. **Default format:** `YYYY-MM-DD`.         |   
		#: +-----------------+---------------------------------------------------------+  
		#: | {{time}}        | Current time. **Default format:** `HH:mm`.              |                            
		#: +-----------------+---------------------------------------------------------+ 
		[schema.new.template]
			[schema.new.template.note]
				template = """
				((frontmatter))
					
				# {{filename}}
					
				## Objective
				<!-- A concise statement explaining the goal of this decision. -->
				{{LOC|50}} 
					
				## Context
				<!-- What is the issue that we're seeing that is motivating this decision or change? -->
				{{LOC|200}} 				
					
				## Decision
				<!-- What is the change that we're proposing and/or doing? -->
				{{LOC|50}} 
					
				## Consequences
				<!-- What becomes easier or more difficult to do because of this change? -->
				{{LOC|50}} 
					
				## Updates
				<!-- Changes that happened when the rubber met the road -->
				{{LOC|100}} 
				"""
```

### something like...

```LLM
1. **Adopt oxide for editor features.** Let it drive:
    - Completions for `[[...]]`, tags, headings/blocks; backlinks UI; rename-updates. [Markdown-Oxide Wiki](https://oxide.md/)
        
2. **Overlay your semantics via your plugin:**
    - On buffer read/change, call your CLI (`get --format json`) → receive parsed wikilinks + your computed edges.
    - **Highlight** custom edge kinds with **extmarks** (you don’t need a Tree-sitter fork).
    - **Completions**: write a tiny `cmp` source that merges oxide LSP items with your CLI index (IDs, tags, ADRs).
        
3. **Validation** remains yours: run `validate --json` and surface diagnostics through Neovim’s `vim.diagnostic` (spans map 1:1).
```

### future... 

```llm 
# Two paths for the Neovim side

## A) Zero-grammar fork (fast to ship)

Use the official **tree-sitter-markdown** (+ `markdown_inline`) for base Markdown. Add semantic highlights and completions via extmarks and `nvim-cmp`:

- For **graph edges** (`[[ADR-123]]`, `depends_on:` in YAML), get byte spans from your **markdown-rs** pass and set highlights via extmarks; you don’t need a new TS node type.
    
- For **tag completions**, use a cmp source that triggers:
    
    - inside YAML `tags:` values, or
        
    - after `[[` (wikilinks)  
        The cmp source can query your project index (IDs, tags) and insert candidates.
        

Pros: no grammar maintenance; works today.  
Cons: highlights are “semantic” (extmarks), not query-driven.

## B) Tiny grammar delta (cleaner long-term)

Fork **tree-sitter-markdown_inline** and add just your inline tokens:

- `wikilink` → children: `(page) (heading?) (alias?)`
    
- `loc_marker` → `{{LOC|N}}`
    
- `filter_pipe` → `{{title|kebab}}`
    
- (optional) `fm_tag` inside front-matter values
    

Then ship minimal queries:

**queries/markdown/highlights.scm**

```scm
; wikilinks
(wikilink (page) @clirag.id)
(wikilink (heading) @clirag.fragment)
(wikilink (alias) @clirag.alias)

; frontmatter tags
(fm_tag) @clirag.tag

; loc markers left in body
(loc_marker) @clirag.todo ; highlight loudly


**queries/markdown/injections.scm** (if you ever want injections)


; e.g., inject dot/mermaid code fences
(fenced_code_block
  (info_string) @injection.language
  (code_fence_content) @injection.content)


Now your **cmp** source can ask “what node is under cursor?” and suggest the right things (IDs for `wikilink/page`, tag values for `fm_tag`). Pros: all UI logic stays in TS queries; cleaner highlighting. Cons: maintain a tiny fork. 
```

## Decision
<!-- What is the change that we're proposing and/or doing? -->

Proceed with markdown-rs and accept the stack in principal knowing some specifics will be hammered out in implementation. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

Fast parsing minimizing code we have to directly maintain where sane. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-012-create-man-pages.md">
---
id: 
tags:
  - documentation
  - man
  - man-page
  - tldr.sh
status: accepted
depends_on: ADR-003b
created_date: 2025-08-27
last_modified: 2025-08-27
related_files: []
---

# create-man-pages

## Objective
<!-- A concise statement explaining the goal of this decision. -->

lean on pandoc to create man pages. not a priority till near 1.0. also create tldr.sh entries. 

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

We should have complete tl;dr and man pages 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

basic expectation of a cli, proceed. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

man pages. 

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

<file path="ADR-013-notebook-documentation.md">
---
id: ADR-013
tags:
  - documentation
  - aesthetics
status: pending
depends_on: ADR-012
created_date: 2025-08-29
last_modified: 2025-08-29
related_files: [/docs/]
---

# ADR-pending-notebook-documentation

## Objective
<!-- A concise statement explaining the goal of this decision. -->

nice looking documentation

## Context
<!-- What is the issue that we're seeing that is motivating this decision or change? -->

ran into a repo that does full juypter notebook docs and didn't realize git displayed them pretty like this, i'll do all the docs in nice notebooks interlinked. 

## Decision
<!-- What is the change that we're proposing and/or doing? -->

low lift, modest reward accepted but no action till 1.0. 

## Consequences
<!-- What becomes easier or more difficult to do because of this change? -->

pretty doc pages \o/

## Updates
<!-- Changes that happened when the rubber met the road -->
</file>

</files>
